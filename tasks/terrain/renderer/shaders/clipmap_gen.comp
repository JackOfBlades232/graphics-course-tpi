#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : require

#include "draw.h"
#include "terrain.h"
#include "materials.h"
#include "constants.h"


layout(local_size_x = BASE_WORK_GROUP_SIZE) in;

layout(binding = 0, set = 0, r32f) uniform writeonly image2D geom[CLIPMAP_LEVEL_COUNT];
layout(binding = 1, set = 0, rgba32f) uniform writeonly image2D albedo[CLIPMAP_LEVEL_COUNT];

layout(push_constant) uniform params_t
{
  uint level;
} params;

layout(binding = 7, set = 0) uniform terrain_source_t
{
  TerrainSourceData source;
};
layout(binding = 8, set = 0) uniform constants_t
{
  Constants constants;
};

#include "bindless.frag.inc"

void main(void)
{
  const uint pix = gl_GlobalInvocationID.x;
  const bool isColor = gl_GlobalInvocationID.y > 0;

  const vec2 worldOffset = constants.toroidalOffset.xz;
  const vec2 worldPos = constants.playerWorldPos.xz;

  ivec2 dims = calculate_toroidal_dims(worldOffset, params.level);

  uint minx = 0, miny = 0;
  if (dims.x < 0)
  {
    dims.x = -dims.x;
    minx = CLIPMAP_RESOLUTION - dims.x;
  }
  if (dims.y < 0)
  {
    dims.y = -dims.y;
    miny = CLIPMAP_RESOLUTION - dims.y;
  }

  const int horizontalPatchSize = CLIPMAP_RESOLUTION * dims.y;
  const int verticalPatchSize = (CLIPMAP_RESOLUTION - dims.y) * dims.x;

  ivec2 flatImgCoord = ivec2(0);
  if (pix < horizontalPatchSize)
  {
    flatImgCoord = ivec2(
      pix % CLIPMAP_RESOLUTION,
      miny + (pix / CLIPMAP_RESOLUTION));
  }
  else if (pix < horizontalPatchSize + verticalPatchSize)
  {
    const uint ppix = pix - horizontalPatchSize;  
    flatImgCoord = ivec2(minx + (ppix % dims.x), ppix / dims.x);
    if (miny == 0)
      flatImgCoord.y += dims.y;
  }
  else
  {
    return;
  }

  const vec2 flatUv = vec2(flatImgCoord) / float(CLIPMAP_RESOLUTION);

  const float clipmapWorldExtent = float(1 << params.level) * CLIPMAP_EXTENT_STEP;
  const float clipmapWorldSize = clipmapWorldExtent * 2.f;

  const vec2 worldCoord = worldPos + (flatUv - 0.5f) * clipmapWorldSize;

  const ivec2 toroidalScrolloff = 
    ivec2((fract(worldPos / clipmapWorldSize) - 0.5f) * CLIPMAP_RESOLUTION);

  const ivec2 destImageCoord = 
    (flatImgCoord + toroidalScrolloff + CLIPMAP_RESOLUTION) % CLIPMAP_RESOLUTION;

  if (isColor)
  {
    // @TODO
  }
  else
  {
    const vec3 terrainExtent = source.rangeMax - source.rangeMin;
    const vec2 uv = (worldCoord - source.rangeMin.xz) / terrainExtent.xz;

    float relHeight = 0.f;
    if (source.heightmapTexSmp != NO_TEXTURE_ID)
    {
      // @TODO: bicubic interpolation by hand
      relHeight = sample_bindless_tex_lod(source.heightmapTexSmp, uv, 0.f).x;
    }

    // @TODO: perturb on noise

    imageStore(geom[params.level], destImageCoord, vec4(relHeight));
  }
}
