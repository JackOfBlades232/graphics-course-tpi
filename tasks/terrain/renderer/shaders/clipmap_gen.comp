#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_GOOGLE_include_directive : require

#include "draw.h"
#include "terrain.h"
#include "materials.h"
#include "constants.h"

#include "common.frag.inc"


layout(local_size_x = BASE_WORK_GROUP_SIZE) in;

layout(binding = 0, set = 0, r32f) uniform writeonly image2D geom[CLIPMAP_LEVEL_COUNT];
layout(binding = 1, set = 0, rgba32f) uniform writeonly image2D normal[CLIPMAP_LEVEL_COUNT];
layout(binding = 2, set = 0, rgba32f) uniform writeonly image2D albedo[CLIPMAP_LEVEL_COUNT];

layout(push_constant) uniform params_t
{
  uint level;
} params;

layout(binding = 7, set = 0) uniform terrain_source_t
{
  TerrainSourceData source;
};
layout(binding = 8, set = 0) uniform constants_t
{
  Constants constants;
};

#include "bindless.frag.inc"

float to_abs_height(float h)
{
  return source.rangeMin.y + h * (source.rangeMax.y - source.rangeMin.y);
}

float sample_height_uv(vec2 uv, vec2 worldUv)
{
  float relHeight = 0.f;
  if (source.heightmapTexSmp != NO_TEXTURE_ID)
    relHeight = sample_bindless_tex_bicubic_lod(source.heightmapTexSmp, uv, 0.f).x;

  // @TEMP just scale back into [0, 1]
  relHeight *= 1.f - 2.f * TERRAIN_NOISE_REL_HEIGHT_AMPLITUDE;
  relHeight += TERRAIN_NOISE_REL_HEIGHT_AMPLITUDE;

  // @TODO seed
  relHeight +=
    simplex_noise(worldUv * TERRAIN_NOISE_PERIOD) *
    TERRAIN_NOISE_REL_HEIGHT_AMPLITUDE;

  return to_abs_height(relHeight);
}

float sample_height(vec2 worldCoord)
{
  const vec3 terrainExtent = source.rangeMax - source.rangeMin;
  const vec2 uv = (worldCoord - source.rangeMin.xz) / terrainExtent.xz;
  return sample_height_uv(uv, uv * terrainExtent.xz);
}

vec3 generate_normal(vec2 worldCoord, float jitter)
{
  const vec3 terrainExtent = source.rangeMax - source.rangeMin;
  const vec2 uv = (worldCoord - source.rangeMin.xz) / terrainExtent.xz;
  const vec2 offs = jitter * terrainExtent.xz;

  const vec2 xl2 = worldCoord - vec2(offs.x, 0.f);
  const vec2 xg2 = worldCoord + vec2(offs.x, 0.f);
  const vec2 zl2 = worldCoord - vec2(0.f, offs.y);
  const vec2 zg2 = worldCoord + vec2(0.f, offs.y);

  const vec2 xluv = uv - vec2(jitter, 0.f);
  const vec2 xguv = uv + vec2(jitter, 0.f);
  const vec2 zluv = uv - vec2(0.f, jitter);
  const vec2 zguv = uv + vec2(0.f, jitter);
  const vec2 xlwuv = xluv * terrainExtent.xz;
  const vec2 xgwuv = xguv * terrainExtent.xz;
  const vec2 zlwuv = zluv * terrainExtent.xz;
  const vec2 zgwuv = zguv * terrainExtent.xz;

  const vec3 xl = vec3(xl2.x, sample_height_uv(xluv, xlwuv), xl2.y);
  const vec3 xg = vec3(xg2.x, sample_height_uv(xguv, xgwuv), xg2.y);
  const vec3 zl = vec3(zl2.x, sample_height_uv(zluv, zlwuv), zl2.y);
  const vec3 zg = vec3(zg2.x, sample_height_uv(zguv, zgwuv), zg2.y);

  return normalize(cross(xg - xl, zl - zg));
}

void main(void)
{
  const uint pix = gl_GlobalInvocationID.x;
  const bool isColor = gl_GlobalInvocationID.y == 1;

  const vec2 worldOffset = constants.toroidalOffset.xz;
  const vec2 worldPos = constants.playerWorldPos.xz;

  ivec2 dims = calculate_toroidal_dims(worldOffset, params.level);

  uint minx = 0, miny = 0;
  if (dims.x < 0)
  {
    dims.x = -dims.x;
    minx = CLIPMAP_RESOLUTION - dims.x;
  }
  if (dims.y < 0)
  {
    dims.y = -dims.y;
    miny = CLIPMAP_RESOLUTION - dims.y;
  }

  const int horizontalPatchSize = CLIPMAP_RESOLUTION * dims.y;
  const int verticalPatchSize = (CLIPMAP_RESOLUTION - dims.y) * dims.x;

  ivec2 flatImgCoord = ivec2(0);
  if (pix < horizontalPatchSize)
  {
    flatImgCoord = ivec2(
      pix % CLIPMAP_RESOLUTION,
      miny + (pix / CLIPMAP_RESOLUTION));
  }
  else if (pix < horizontalPatchSize + verticalPatchSize)
  {
    const uint ppix = pix - horizontalPatchSize;  
    flatImgCoord = ivec2(minx + (ppix % dims.x), ppix / dims.x);
    if (miny == 0)
      flatImgCoord.y += dims.y;
  }
  else
  {
    return;
  }

  const vec2 flatUv = vec2(flatImgCoord) / float(CLIPMAP_RESOLUTION);

  const float clipmapWorldExtent = float(1 << params.level) * CLIPMAP_EXTENT_STEP;
  const float clipmapWorldSize = clipmapWorldExtent * 2.f;

  const vec2 worldCoord = worldPos + (flatUv - 0.5f) * clipmapWorldSize;

  const ivec2 toroidalScrolloff = 
    ivec2((fract(worldPos / clipmapWorldSize) - 0.5f) * CLIPMAP_RESOLUTION);

  const ivec2 destImageCoord = 
    (flatImgCoord + toroidalScrolloff + CLIPMAP_RESOLUTION) % CLIPMAP_RESOLUTION;

  if (isColor)
  {
    // @TODO
  }
  else
  {
    // @TODO: split normal & h?
    const float h = sample_height(worldCoord);
    const vec3 n = generate_normal(
      worldCoord, TERRAIN_NORMAL_SAMPLING_PIXEL_OFFS / float(CLIPMAP_RESOLUTION));

    imageStore(geom[params.level], destImageCoord, vec4(h));
    imageStore(normal[params.level], destImageCoord, vec4(n, 1.f));
  }
}
