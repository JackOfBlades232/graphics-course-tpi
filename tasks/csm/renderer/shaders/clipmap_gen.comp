#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "draw.h"
#include "constants.h"
#include "terrain.h"

#include "common.frag.inc"

// @TODO:
//  on low framerate clipmap has artifacts. Fix!


layout(local_size_x = CLIPMAP_WORK_GROUP_SIZE) in;

layout(binding = 0, set = 0, r32f) uniform writeonly image2D geom[CLIPMAP_LEVEL_COUNT];
layout(binding = 1, set = 0, rgba32f) uniform writeonly image2D normal[CLIPMAP_LEVEL_COUNT];
layout(binding = 2, set = 0, rgba32f) uniform writeonly image2D albedo[CLIPMAP_LEVEL_COUNT];
layout(binding = 3, set = 0, rgba32f) uniform writeonly image2D matdata[CLIPMAP_LEVEL_COUNT];

layout(push_constant) uniform params_t
{
  uint level;
} params;

layout(binding = 7, set = 0) uniform terrain_source_t
{
  TerrainSourceData source;
};
layout(binding = 8, set = 0) uniform constants_t
{
  Constants constants;
};

#include "material_mesh.glsl.inc"

float to_abs_height(float h)
{
  return source.rangeMin.y + h * (source.rangeMax.y - source.rangeMin.y);
}

float sample_rel_height_uv(vec2 uv, vec2 worldUv)
{
  float relHeight = 0.f;
  if (source.heightmapTexSmp != NO_TEXTURE_ID)
    relHeight = sample_bindless_tex_bicubic_lod(source.heightmapTexSmp, uv, 0.f).x;

  // @TEMP just scale back into [0, 1]
  relHeight *= 1.f - 2.f * TERRAIN_NOISE_REL_HEIGHT_AMPLITUDE;
  relHeight += TERRAIN_NOISE_REL_HEIGHT_AMPLITUDE;

  // @TODO seed
  relHeight +=
    simplex_noise(worldUv * TERRAIN_NOISE_PERIOD) *
    TERRAIN_NOISE_REL_HEIGHT_AMPLITUDE;

  return relHeight;
}

float sample_height_uv(vec2 uv, vec2 worldUv)
{
  return to_abs_height(sample_rel_height_uv(uv, worldUv));
}

float sample_rel_height(vec2 worldCoord)
{
  const vec3 terrainExtent = source.rangeMax - source.rangeMin;
  const vec2 uv = (worldCoord - source.rangeMin.xz) / terrainExtent.xz;
  return sample_rel_height_uv(uv, uv * terrainExtent.xz);
}

float sample_height(vec2 worldCoord)
{
  return to_abs_height(sample_rel_height(worldCoord));
}

vec3 generate_normal(vec2 worldCoord, float jitter)
{
  const vec3 terrainExtent = source.rangeMax - source.rangeMin;
  const vec2 uv = (worldCoord - source.rangeMin.xz) / terrainExtent.xz;
  const vec2 offs = jitter * terrainExtent.xz;

  const vec2 xl2 = worldCoord - vec2(offs.x, 0.f);
  const vec2 xg2 = worldCoord + vec2(offs.x, 0.f);
  const vec2 zl2 = worldCoord - vec2(0.f, offs.y);
  const vec2 zg2 = worldCoord + vec2(0.f, offs.y);

  const vec2 xluv = uv - vec2(jitter, 0.f);
  const vec2 xguv = uv + vec2(jitter, 0.f);
  const vec2 zluv = uv - vec2(0.f, jitter);
  const vec2 zguv = uv + vec2(0.f, jitter);
  const vec2 xlwuv = xluv * terrainExtent.xz;
  const vec2 xgwuv = xguv * terrainExtent.xz;
  const vec2 zlwuv = zluv * terrainExtent.xz;
  const vec2 zgwuv = zguv * terrainExtent.xz;

  const vec3 xl = vec3(xl2.x, sample_height_uv(xluv, xlwuv), xl2.y);
  const vec3 xg = vec3(xg2.x, sample_height_uv(xguv, xgwuv), xg2.y);
  const vec3 zl = vec3(zl2.x, sample_height_uv(zluv, zlwuv), zl2.y);
  const vec3 zg = vec3(zg2.x, sample_height_uv(zguv, zgwuv), zg2.y);

  return normalize(cross(xg - xl, zl - zg));
}

void main(void)
{
  const uint pix = gl_GlobalInvocationID.x;

  const vec2 worldOffset = constants.toroidalOffset.xz;
  const vec2 worldPos = constants.toroidalUpdatePlayerWorldPos.xz;

  ivec2 dims = calculate_toroidal_dims(worldOffset, params.level);

  uint minx = 0, miny = 0;
  if (dims.x < 0)
  {
    dims.x = -dims.x;
    minx = CLIPMAP_RESOLUTION - dims.x;
  }
  if (dims.y < 0)
  {
    dims.y = -dims.y;
    miny = CLIPMAP_RESOLUTION - dims.y;
  }

  const int horizontalPatchSize = CLIPMAP_RESOLUTION * dims.y;
  const int verticalPatchSize = (CLIPMAP_RESOLUTION - dims.y) * dims.x;

  ivec2 flatImgCoord = ivec2(0);
  if (pix < horizontalPatchSize)
  {
    flatImgCoord = ivec2(
      pix % CLIPMAP_RESOLUTION,
      miny + (pix / CLIPMAP_RESOLUTION));
  }
  else if (pix < horizontalPatchSize + verticalPatchSize)
  {
    const uint ppix = pix - horizontalPatchSize;  
    flatImgCoord = ivec2(minx + (ppix % dims.x), ppix / dims.x);
    if (miny == 0) flatImgCoord.y += dims.y;
  }
  else
  {
    return;
  }

  const vec2 flatUv = vec2(flatImgCoord) / float(CLIPMAP_RESOLUTION);

  const float clipmapWorldExtent = float(1 << params.level) * CLIPMAP_EXTENT_STEP;
  const float clipmapWorldSize = clipmapWorldExtent * 2.f;

  const vec2 worldCoord = worldPos + (flatUv - 0.5f) * clipmapWorldSize;

  const ivec2 toroidalScrolloff = 
    ivec2((fract(worldPos / clipmapWorldSize) - 0.5f) * CLIPMAP_RESOLUTION);

  const ivec2 destImageCoord = 
    (flatImgCoord + toroidalScrolloff + CLIPMAP_RESOLUTION) % CLIPMAP_RESOLUTION;

  float h = 0.f;
  vec3 n = vec3(0.f);
  vec3 color = vec3(0.f);
  vec3 matData = vec3(0.f); // Ok to interpolate, cuz mat type is verified to be the same

  {
    float rh = sample_rel_height(worldCoord);

    // @TODO: on one hand, displacement should participate in normal gen.
    // On the other hand, it means doing the detail loop for each of the 4
    // pixels. Either way, rn disp looks like shit
    const vec3 baseN = generate_normal(
      worldCoord, TERRAIN_NORMAL_SAMPLING_PIXEL_OFFS / float(CLIPMAP_RESOLUTION));

    // U gradient is vec2(1, 0) => take tang as the projection of vec(1,0)
    // onto the orthogonal plane to the normal
    const vec3 grad = vec3(1.f, 0.f, 0.f);
    const vec3 gnproj = baseN * dot(grad, baseN);
    const vec4 tang = vec4(normalize(grad - gnproj), 1.f); // @TODO: is this correct?

    float disp = 0.f;
    float totw = 0.f;

    for (uint i = 0; i < source.detailCount; ++i)
    {
      const vec2 scale = source.details[i].uvScale; 
      const vec2 uv = worldCoord / scale; 

      float w = 0.f; 

      if ((source.details[i].flags & TERRAIN_DETAIL_USE_MASK_FLAG) != 0)
      {
        // @TODO
      }
      if ((source.details[i].flags & TERRAIN_DETAIL_USE_RH_RANGE_FLAG) != 0)
      {
        float ld = max(source.details[i].heightRange.x - rh, 0.f);
        float hd = max(rh - source.details[i].heightRange.y, 0.f);

        // @TODO: correct when there can be another source of w (splatting)
        float lw = 1.f - min(ld / TERRAIN_DETAIL_LEVEL_FALLOFF, 1.f);
        float hw = 1.f - min(hd / TERRAIN_DETAIL_LEVEL_FALLOFF, 1.f);

        w = min(lw, hw);
      }

      if (w > SHADER_EPSILON)
      {
        // @TODO: bring this back into one call
        const vec3 detCol = get_pixel_albedo_lod(source.details[i].matId, uv, float(params.level)).xyz;
        const vec3 detMatdata = get_pixel_matdata_lod(source.details[i].matId, uv, float(params.level));
        const vec3 detNorm = get_pixel_normal_lod(source.details[i].matId, baseN, tang, uv, float(params.level));

        {
          const uint matId = source.details[i].matId;
          if (matId != NO_MATERIAL)
          {
            const TexSmpIdPair dispTexId = materialParams[matId].heightDisplacementTexSmp;
            const float dispCoeff = materialParams[matId].displacementCoeff;

            if (dispTexId != NO_TEXTURE_ID && abs(dispCoeff) > SHADER_EPSILON)
            {
              disp += sample_bindless_tex_lod(dispTexId, uv, float(params.level)).x * dispCoeff;
            }
          }
        }

        color += detCol;
        matData += detMatdata;
        n += detNorm;
        totw += w;
      }
    }

    if (constants.drawTerrainSplattedDetail == 0)
    {
      color = vec3(0.2, 0.8, 0.5);
      matData = vec3(float(MATERIAL_DIFFUSE), 0.f, 0.f);
      n = baseN;
    }
    else
    {
      rh += disp / totw;
      color /= totw;
      matData /= totw;
      n = normalize(n / totw);
    }
    h = to_abs_height(rh);
  }

  imageStore(geom[params.level], destImageCoord, vec4(h));
  imageStore(normal[params.level], destImageCoord, vec4(n, 1.f));
  imageStore(albedo[params.level], destImageCoord, vec4(color, 1.f));
  imageStore(matdata[params.level], destImageCoord, vec4(matData, 1.f));
}
