#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "tonemapping.h"
#include "constants.h"
#include "cpp_glsl_compat.h"


layout(local_size_x = HISTOGRAM_WORK_GROUP_SIZE) in;

layout(binding = 0, set = 0) uniform sampler2D hdrImage;
layout(binding = 1, set = 0) buffer hist_t
{
  HistogramData data;
};
layout(binding = 2, set = 0) buffer jnd_bins_t
{
  uint jndBins[];
};

layout(binding = 8, set = 0) uniform constants_t
{
  Constants constants;
};

float load_luminance(ivec2 coord, ivec2 size)
{
  const vec4 col = textureLod(hdrImage, vec2(coord) / vec2(size), 0);
  return luminance_bt601(col);
}

void main(void)
{
  const float binSize =
    (data.maxLogLuminance - data.minLogLuminance) / float(HISTOGRAM_BINS);

  const ivec2 imSz = ivec2(textureSize(hdrImage, 0));
  const int imPixels = imSz.x * imSz.y;

  const int globId = int(gl_GlobalInvocationID.x);
  const int localFirstPixel = globId * HISTOGRAM_PIXELS_PER_THREAD;
  const int localPixelCount = min(HISTOGRAM_PIXELS_PER_THREAD, imPixels - localFirstPixel);

  for (int p = localFirstPixel; p < localFirstPixel + localPixelCount; ++p)
  {
    const ivec2 imCoord = ivec2(p % imSz.x, p / imSz.x);
    const float luminance = load_luminance(imCoord, imSz);

    if (
      luminance < constants.tonemappingMinAdmissibleLum ||
      luminance > constants.tonemappingMaxAdmissibleLum)
    {
      continue;
    }

    const float logLuminance = to_logscale(luminance);

    const uint rbin = uint(floor((logLuminance - data.minLogLuminance) / binSize));
    const uint bin = clamp(rbin, 0, HISTOGRAM_BINS - 1);
    atomicAdd(data.binsDensity[bin], 1);

    const float inBinOffset = logLuminance - float(bin) * binSize;
    const uint refinedLocBin = uint(floor(inBinOffset / data.binsRefinedJnds[bin]));

    const uint refinedBin =
      (bin == 0 ? 0 : data.binsRefinedBinCumCounts[bin - 1]) + refinedLocBin;

    const uint bucket = refinedBin >> 5;
    const uint bit = 1 << (refinedBin & 31);
    const uint prev = atomicOr(jndBins[bucket], bit);
    if ((prev & bit) == 0)
      atomicAdd(data.binsRefinedDensity[bin], 1);
  }
}
