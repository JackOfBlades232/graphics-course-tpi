#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "tonemapping.h"
#include "constants.h"
#include "cpp_glsl_compat.h"


layout(local_size_x = HISTOGRAM_WORK_GROUP_SIZE) in;

layout(binding = 0, set = 0) uniform sampler2D hdrImage;
layout(binding = 1, set = 0) buffer hist_t
{
  HistogramData data;
};

float load_luminance(ivec2 coord, ivec2 size)
{
  const vec4 col = textureLod(hdrImage, vec2(coord) / vec2(size), 0);
  return luminance_bt601(col);
}

void main(void)
{
  // @NOTE: can't use min/maxLuminance or min/minLogLuminance yet, as it's not computed
  const float minLuminance = normalized_to_luminance(data.minNormLuminance);
  const float maxLuminance = normalized_to_luminance(data.maxNormLuminance);

  const float minLogLuminance = to_log10(minLuminance);
  const float maxLogLuminance = to_log10(maxLuminance);
  const float binSize = (maxLogLuminance - minLogLuminance) / float(HISTOGRAM_BINS);

  const ivec2 imSz = ivec2(textureSize(hdrImage, 0));
  const int imPixels = imSz.x * imSz.y;

  const int globId = int(gl_GlobalInvocationID.x);
  const int localFirstPixel = globId * HISTOGRAM_PIXELS_PER_THREAD;
  const int localPixelCount = min(HISTOGRAM_PIXELS_PER_THREAD, imPixels - localFirstPixel);

  for (int p = localFirstPixel; p < localFirstPixel + localPixelCount; ++p)
  {
    const ivec2 imCoord = ivec2(p % imSz.x, p / imSz.x);
    const float logLuminance = to_log10(load_luminance(imCoord, imSz));

    const uint bin = uint(floor((logLuminance - minLogLuminance) / binSize));
    atomicAdd(data.binsDensity[clamp(bin, 0, HISTOGRAM_BINS - 1)], 1);
  }
}
