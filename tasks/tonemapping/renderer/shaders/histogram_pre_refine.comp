#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "tonemapping.h"
#include "constants.h"
#include "cpp_glsl_compat.h"


layout(local_size_x = HISTOGRAM_WORK_GROUP_SIZE) in;

layout(binding = 0, set = 0) uniform sampler2D hdrImage;
layout(binding = 1, set = 0) buffer hist_t
{
  HistogramData data;
};
layout(binding = 2, set = 0) writeonly buffer binned_luminances_t
{
  float binnedLogLuminances[];
};

float load_luminance(ivec2 coord, ivec2 size)
{
  const vec4 col = textureLod(hdrImage, vec2(coord) / vec2(size), 0);
  return luminance_bt601(col);
}

void main(void)
{
  const ivec2 imSz = ivec2(textureSize(hdrImage, 0));

  // @TODO: pull binning logic out
  const float minLuminance = normalized_to_luminance(data.minNormLuminance);
  const float maxLuminance = normalized_to_luminance(data.maxNormLuminance);

  const float minLogLuminance = to_logscale(minLuminance);
  const float maxLogLuminance = to_logscale(maxLuminance);

  const float binSize = (maxLogLuminance - minLogLuminance) / float(HISTOGRAM_BINS);
  const int globId = int(gl_GlobalInvocationID.x);
  const int localFirstPixel = globId * HISTOGRAM_PIXELS_PER_THREAD;
  const int localPixelCount =
    min(HISTOGRAM_PIXELS_PER_THREAD, binnedLogLuminances.length() - localFirstPixel);

  for (int p = localFirstPixel; p < localFirstPixel + localPixelCount; ++p)
  {
    const ivec2 imCoord = ivec2(p % imSz.x, p / imSz.x);
    const float logLuminance = to_logscale(load_luminance(imCoord, imSz));

    const uint bin = clamp(
      uint(floor((logLuminance - minLogLuminance) / binSize)),
      0, HISTOGRAM_BINS - 1);

    const uint offs = bin == 0 ? 0 : data.binsCumCount[bin - 1];
    binnedLogLuminances[offs + atomicAdd(data.binsRefinedDensity[bin], 1)] = logLuminance;
  }
}
