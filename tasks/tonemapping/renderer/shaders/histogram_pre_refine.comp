#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "tonemapping.h"
#include "constants.h"
#include "cpp_glsl_compat.h"


layout(local_size_x = HISTOGRAM_WORK_GROUP_SIZE) in;

layout(binding = 0, set = 0) buffer hist_t
{
  HistogramData data;
};

// @TODO: i want to do linear bins on log jnd. This is not correct!
//        but how do I fix? I think I need to do some inverse transform.

float calculate_jnd(float lum)
{
  // Not to_logscale, because formula doesn't do +1 to arg
  const float loglum = log(lum) / log(10.f);
  float logjnd;

  if (lum < SHADER_EPSILON || loglum < -3.94f)
    logjnd = -3.81f;
  else if (loglum < -1.44f)
    logjnd = pow(0.405f * loglum + 1.6f, 2.18f) - 3.81;
  else if (loglum < -0.0184f)
    logjnd = loglum - 1.345f;
  else if (loglum < 1.9)
    logjnd = pow(0.249f * loglum + 0.65f, 2.7f) - 1.67;
  else
    logjnd = loglum - 2.205f;

  return exp(logjnd * log(10.f));
}

void main(void)
{
  data.minLuminance = normalized_to_luminance(data.minNormLuminance);
  data.maxLuminance = normalized_to_luminance(data.maxNormLuminance);

  data.minLogLuminance = to_logscale(data.minLuminance);
  data.maxLogLuminance = to_logscale(data.maxLuminance);

  const float binSize = 
    (data.maxLogLuminance - data.minLogLuminance) / float(HISTOGRAM_BINS);

  for (int i = 0; i < HISTOGRAM_BINS; ++i)
  {
    const float minBinLog = data.minLogLuminance + float(i) * binSize;
    const float maxBinLog = minBinLog + binSize;

    const float binCenter = from_logscale((minBinLog + maxBinLog) * 0.5f);

    const float logJnd = to_logscale(calculate_jnd(binCenter));
    data.binsRefinedJnds[i] = logJnd;
    data.binsRefinedBinCounts[i] = uint(ceil(binSize / logJnd));

    data.binsRefinedBinCumCounts[i] = data.binsRefinedBinCounts[i] +
      (i == 0 ? 0 : data.binsRefinedBinCumCounts[i - 1]);
  }
}
