#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "tonemapping.h"
#include "constants.h"
#include "cpp_glsl_compat.h"


layout(local_size_x = HISTOGRAM_MINMAX_WORK_GROUP_SIZE) in;

layout(binding = 0, set = 0) uniform sampler2D hdrImage;
layout(binding = 1, set = 0) buffer minmax_t
{
  HistogramLuminanceRange range;
};

layout(binding = 8, set = 0) uniform constants_t
{
  Constants constants;
};

float load_luminance(ivec2 coord, ivec2 size)
{
  const vec4 col = textureLod(hdrImage, vec2(coord) / vec2(size), 0);
  return luminance_bt601(col);
}

shared HistogramLuminanceRange minmaxSharedBuffer[HISTOGRAM_MINMAX_WORK_GROUP_SIZE];

void main(void)
{
  const ivec2 imSz = ivec2(textureSize(hdrImage, 0));
  const int imPixels = imSz.x * imSz.y;

  const int globId = int(gl_GlobalInvocationID.x);
  const int localFirstPixel = globId * PIXELS_PER_THREAD;
  const int localPixelCount = min(PIXELS_PER_THREAD, imPixels - localFirstPixel);

  uint localMin = SHADER_UINT_MAX;
  uint localMax = 0;
  for (int p = localFirstPixel; p < localFirstPixel + localPixelCount; ++p)
  {
    const ivec2 imCoord = ivec2(p % imSz.x, p / imSz.x);
    const float luminance = load_luminance(imCoord, imSz);
    const uint nlum = luminance_to_normalized(luminance);

    localMin = min(localMin, nlum);
    localMax = max(localMax, nlum);
  }

  if (constants.useSharedMemForTonemapping == 0)
  {
    if (globId < imPixels)
    {
      atomicMin(range.min, localMin);
      atomicMax(range.max, localMax);
    }
  }
  else
  {
    const int locId = int(gl_LocalInvocationID.x);
    minmaxSharedBuffer[locId].min = localMin;
    minmaxSharedBuffer[locId].max = localMax;

    barrier();

    for (int skip = 1; skip < HISTOGRAM_MINMAX_WORK_GROUP_SIZE; skip <<= 1)
    {
      if (locId % skip == 0)
      {
        const int nextId = locId + skip;
        if (nextId < HISTOGRAM_MINMAX_WORK_GROUP_SIZE)
        {
          minmaxSharedBuffer[locId].min = min(minmaxSharedBuffer[locId].min, minmaxSharedBuffer[nextId].min);
          minmaxSharedBuffer[locId].max = max(minmaxSharedBuffer[locId].max, minmaxSharedBuffer[nextId].max);
        }
      }

      barrier();
    }

    if (locId == 0)
    {
      atomicMin(range.min, minmaxSharedBuffer[0].min);
      atomicMax(range.max, minmaxSharedBuffer[0].max);
    }
  }
}
